"""Build the auto-generated players registry.

Scans `tournament.players` for Python files, imports them, finds classes that
subclass `axelrod.Player`, and writes `tournament/players/_registry.py` with
static imports and a list `REGISTERED_PLAYERS` along with
`get_registered_players()`.

Usage:
    python -m tournament.scripts.build_registry [--dry-run] [--verbose]

Exit codes:
    0: success, registry written (or would be written in dry-run)
    1: no players found (registry still written but empty) or validation issues
    2: fatal error
"""
from __future__ import annotations

import argparse
import datetime as _dt
import importlib
import inspect
import sys
from pathlib import Path
from typing import List, Tuple, Type

from axelrod import Player, Action


def find_players(verbose: bool = False) -> List[Tuple[str, str, Type]]:
    """Return a list of (module_name, class_name, class_obj) for Player subclasses.

    Only classes defined in the module itself are included (ignores re-exported
    classes). Files that start with '_' and `__init__.py` are ignored.
    """
    players: List[Tuple[str, str, Type]] = []

    try:
        pkg = importlib.import_module("tournament.players")
    except Exception as e:  # pragma: no cover
        raise RuntimeError(f"Failed to import package tournament.players: {e}")

    # Resolve filesystem directory of the package
    try:
        pkg_paths = list(pkg.__path__)  # type: ignore[attr-defined]
        players_dir = Path(pkg_paths[0])
    except Exception as e:  # pragma: no cover
        raise RuntimeError(f"Unable to resolve players package path: {e}")

    for file in sorted(players_dir.glob("*.py")):
        if file.name == "__init__.py":
            continue
        if file.name.startswith("_") and file.name != "_registry.py":
            # skip other internal helpers; _registry is generated target
            continue

        modulename = f"tournament.players.{file.stem}"
        try:
            mod = importlib.import_module(modulename)
        except Exception as e:
            if verbose:
                print(f"[build_registry] Skipping {file.name}: import failed: {e}")
            continue

        for name, obj in inspect.getmembers(mod, inspect.isclass):
            # ensure defined in this module
            if getattr(obj, "__module__", None) != modulename:
                continue
            # must be subclass of axelrod.Player
            try:
                if issubclass(obj, Player) and obj is not Player:
                    players.append((modulename, name, obj))
            except Exception:
                # Non-new-style classes or weird bases: skip
                continue

    # Deterministic ordering by module then class name
    players.sort(key=lambda t: (t[0], t[1]))
    return players


def generate_registry_source(discovered: List[Tuple[str, str, Type]]) -> str:
    ts = _dt.datetime.now().isoformat(timespec="seconds")
    header = (
        "# Auto-generated by tournament.scripts.build_registry\n"
        f"# Generated at: {ts}\n"
        "# Do not edit manually. Run the builder to update.\n"
    )

    # Build import lines grouping by module
    imports_by_module: dict[str, list[str]] = {}
    for module, cls_name, _ in discovered:
        imports_by_module.setdefault(module, []).append(cls_name)

    import_lines: List[str] = []
    for module in sorted(imports_by_module):
        classes = ", ".join(sorted(imports_by_module[module]))
        # Convert fully qualified module `tournament.players.mod` -> relative `.mod`
        if not module.startswith("tournament.players."):
            rel_module = module
        else:
            rel_module = "." + module.split(".", 2)[2]
        import_lines.append(f"from {rel_module} import {classes}")

    # Build list of names for REGISTERED_PLAYERS
    names_list = ",\n    ".join([cls for _, cls, _ in discovered])

    body = (
        "from __future__ import annotations\n\n"
        "from typing import List, Type\n\n"
        + ("\n".join(import_lines) + "\n\n" if import_lines else "")
        + "# List of player classes to include in tournaments by default.\n"
        + "REGISTERED_PLAYERS: List[Type] = [\n    "
        + names_list
        + "\n]" 
        + "\n\n\n"
        + "def get_registered_players() -> List[Type]:\n"
        + "    \"\"\"Return the list of registered player classes.\"\"\"\n"
        + "    return list(REGISTERED_PLAYERS)\n"
    )

    return header + "\n" + body + "\n"


def write_registry(source: str, *, verbose: bool = False) -> Path:
    # Locate the target file path
    pkg = importlib.import_module("tournament.players")
    pkg_path = Path(list(pkg.__path__)[0])  # type: ignore[attr-defined]
    target = pkg_path / "_registry.py"
    target.write_text(source, encoding="utf-8")
    if verbose:
        print(f"[build_registry] Wrote registry to {target}")
    return target


def main(argv: List[str] | None = None) -> int:
    parser = argparse.ArgumentParser(description="Build the players registry by scanning players package.")
    parser.add_argument("--dry-run", action="store_true", help="Print the generated registry to stdout instead of writing")
    parser.add_argument("--verbose", action="store_true", help="Verbose logging of discovered classes and decisions")
    args = parser.parse_args(argv)

    try:
        discovered = find_players(verbose=args.verbose)
    except Exception as e:
        print(f"Fatal error: {e}")
        return 2

    if args.verbose:
        print("[build_registry] Discovered player classes:")
        if not discovered:
            print("  (none)")
        for module, cls_name, _ in discovered:
            print(f"  - {module}:{cls_name}")

    source = generate_registry_source(discovered)

    if args.dry_run:
        print(source)
    else:
        write_registry(source, verbose=args.verbose)

    # Return non-zero if nothing was found to signal attention upstream
    if not discovered:
        return 1
    return 0


if __name__ == "__main__":  # pragma: no cover
    raise SystemExit(main())
